---
title: "Hijacking IAM Roles and Avoiding Detection"
date: 2019-07-01T17:16:40-06:00
description: A guide on how to steal IAM role keys and use them without being detected
link: hijack-iam-roles-and-avoid-detection
image: https://frichetten.com/images/thumbs/hijack-iam-roles-and-avoid-detection
type: "blog"
---
<p>A common problem when building secure infrastructure is authentication. How do you allow your server to authenticate with other services securely? AWS provides a simple way to manage authentication to resources through <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/iam-roles-for-amazon-ec2.html">IAM roles</a>. IAM roles allow you to provide an EC2 instance with a set of permissions to the AWS API. This drastically makes things easier for developers but also introduces some unique security concerns.</p><p>Rather than storing credentials on the EC2 instance themselves, IAM roles will manage the credentials for us and rotate them on a regular basis through the <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html">Instance metadata service</a>. This service is available at http://169.254.169.254, and can only be accessed from the EC2 instance. There’s a slight problem however, an attacker could hijack them, and make AWS API requests with the privilege of the EC2 instance. Even more concerning, they can do this without triggering a <a href="https://aws.amazon.com/guardduty/">GuardDuty</a> alert. How? Let’s find out.</p><h3>Hijacking IAM Role Keys</h3><p>As an attacker, our goal is to reach the instance metadata service <i>through</i> the EC2 instance. Two common ways of doing this are through <a href="https://www.owasp.org/index.php/Server_Side_Request_Forgery">Server Side Request Forgery</a> and direct code execution on the system. For the purposes of this article, we will demonstrate the SSRF route.</p><p>First, let’s create an IAM role called "SecureS3Role" that has access to S3. We will then create an EC2 instance and attach the role we just created. Finally, let’s create an S3 bucket for us to query.</p><p style="text-align:center"><img src="/images/blog/hijack-iam-roles-and-avoid-detection/create_s3.png" alt="Showing the SecureS3 IAM Role" style="max-width:95%" class="img-responsive" /></p><p style="text-align:center"><img src="/images/blog/hijack-iam-roles-and-avoid-detection/s3_bucket.png" alt="The super-top-secret-bucket-please-dont-hack S3 bucket" style="max-width:95%"/></p><p>Next, we need to create a vulnerable service on the EC2 instance. For this, we will use an example created by Jobert Abma for <a href="https://www.hackerone.com/blog-How-To-Server-Side-Request-Forgery-SSRF">this</a> HackerOne blog article. This will create a simple web server that is vulnerable to SSRF.</p><p>To show the vulnerability in action, here is my website being fetched through SSRF (and rendering it in a broken fashion).</p><p style="text-align:center"><img src="/images/blog/hijack-iam-roles-and-avoid-detection/broken_website.png" alt="Showing my website fetched through SSRF" style="max-width:95%"/></p><p>Our next goal will be to reach out to the instance metadata service and get access to the IAM role keys. There is a slight trick here in that we need to identify the name of the IAM role associated with the EC2 instance. Thankfully the instance metadata service will provide this for us. Simply reach out to the following endpoint.</p><center><code>http://169.254.169.254/latest/meta-data/iam/security-credentials/</code></center><br><p>The response from the instance metadata service will give us the name of the IAM role we are attempting to hijack.</p><p style="text-align:center"><img src="/images/blog/hijack-iam-roles-and-avoid-detection/iam_role.png" alt="Getting the IAM role to steal" style="max-width:95%"/></p><p>Simply append this name to the previous query (ensure you include a "/" at the end of the name) and you will get the following result.</p><p style="text-align:center"><img src="/images/blog/hijack-iam-roles-and-avoid-detection/iam_keys.png" alt="Showing the stolen IAM keys" style="max-width:95%"/></p><p>(As far as I’m aware there is no risk in revealing old IAM keys, however it still makes me nervous, thus why I’ve obfuscated the results)</p><p>We now have everything we need to make requests to the AWS API. There are a few ways you can do this, first, you could use something like <a href="https://github.com/RhinoSecurityLabs/pacu">Pacu</a> and its modules to enumerate what access that role has. Alternatively you could open a terminal prompt and use "export" as defined <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html">here</a> to temporarily set privileges with the AWS CLI. Personally, I like to use <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-profiles.html">name profiles</a> with the AWS CLI. This has a few advantages, for instance being able to seamlessly swap between different sets of credentials (assuming your pentest is going well) using the "--profile" flag.</p><h3>Avoiding Detection</h3><p>Before we use these keys, let’s take a moment to talk about detection. Because this is a common attack, AWS’s GuardDuty will detect it. If you aren’t familiar with GuardDuty, it is AWS’s built in threat detection service that will detect common attacks using CloudTrail, VPC Flow Logs, and DNS Logs.</p><p>The detection that would hamper our efforts is specifically called <a href="https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_unauthorized.html#unauthorized11" style="word-wrap:break-word">UnauthorizedAccess:IAMUser/InstanceCredentialExfiltration</a>. As described, "This finding informs you of attempts to run AWS API operations from a host outside of EC2, using temporary AWS credentials that were created on an EC2 instance in your AWS account".</p><p>Sounds pretty effective right? And because we are only abusing SSRF (and thus, don’t have a foothold on the EC2 instance) it sounds like this would quickly detect us and the defenders would quickly shut us down, right? The good news for us, and bad news for defenders is that there is a pretty significant loophole here. The description from the previous paragraph is 100% accurate. API operations from a host outside of EC2 is the only thing that triggers this. So, if we steal those IAM keys and use them from another EC2 instance, even one that we own, no alert will be fired.</p><p>A better way to understand this is that GuardDuty only checks that the source IP is in the range of EC2 IP addresses. So long as it is, the alert will not fire. This is covered in Rhino Security’s book, <a href="https://www.amazon.com/dp/1789136725/ref=cm_sw_r_cp_ep_dp_gJ0CBbVZQBR6Y">"Hands-On AWS Penetration Testing with Kali Linux"</a>. If you’re looking to get more familiar with AWS Penetration Testing I would highly encourage you to pick it up. To my mind, Rhino Security is the industry leader in AWS pentesting.</p><p>So how do we exploit our access without being alerted on? First, let’s create a new EC2 Instance in our account (note: I’ve used <a href="https://aws.amazon.com/organizations/">AWS Organizations</a> to ensure all requests originate from a unique account).</p><p>Once the instance is ready, we log in, install the AWS CLI, and then create a new credential file using the IAM keys we stole from the victim.</p><p style="text-align:center"><img src="/images/blog/hijack-iam-roles-and-avoid-detection/create_credentials.png" alt="Creating the credentials file" style="max-width:95%"/></p><p style="text-align:center"><img src="/images/blog/hijack-iam-roles-and-avoid-detection/add_keys.png" alt="Adding the stolen keys to the credentials file" style="max-width:95%"/></p><p>Next, let’s query S3 and see what we have access to.</p><p style="text-align:center"><img src="/images/blog/hijack-iam-roles-and-avoid-detection/query_s3.png" alt="Querying S3" style="max-width:95%"/></p><p>Interesting, we have access to an S3 bucket! Unfortunately for us, it is empty. For the sake of demonstration, let’s send a message to the defenders by uploading a text file to the S3 bucket.</p><p style="text-align:center"><img src="/images/blog/hijack-iam-roles-and-avoid-detection/send_message.png" alt="Adding a file to S3" style="max-width:95%"/></p><p>Next, let’s wait a bit for GuardDuty to catch up. It normally takes 5-15 minutes. For the purposes for this demonstration, I waited half and hour. This is the result:</p><p style="text-align:center"><img src="/images/blog/hijack-iam-roles-and-avoid-detection/no_findings.png" alt="Showing GuardDuty having no findings" style="max-width:95%"/></p><p>GuardDuty is none the wiser to us hijacking the IAM keys.</p><h3>Getting Caught</h3><p>If we were careless, or didn’t know about this post-exploitation trick, we may move the IAM keys to our own box and run API calls.</p><p>This will create the following finding in GuardDuty.</p><p style="text-align:center"><img src="/images/blog/hijack-iam-roles-and-avoid-detection/caught.png" alt="Showing what it would look like if GuardDuty caught us" style="max-width:95%"/></p><h3>Terminating the Instance</h3><p>One last topic I’d like to cover before I end this article is the following questions: What happens if I terminate the instance? Do the IAM keys still work?</p><p>Your instinct may be to think "If the IAM keys are tied to the instance, and I terminate the instance, then they should be invalidated shortly after the instance is shut down". Unfortunately this is not the case. Those keys are valid, and will last until their pre-determined expiration time. By default this is six hours. So we, as attackers, can steal those keys and use them for the remainder of their lifetime, even if the instance is turned off.</p><p>With that, I hope I’ve given you a simple overview of how to manipulate IAM keys. Was there anything I missed? Feel free to send me an email!</p>
